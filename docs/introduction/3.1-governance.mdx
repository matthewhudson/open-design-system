import { Meta, Status, Intro, Props } from '../../.storybook/components';

<Meta title="Introduction/Governance/Intro" />

# Governance Process

<Intro>
Design systems evolve with the organization, offering components, documentation, and a unified design language for product teams. This guide details governance for creating, approving, and deploying components, balancing speed with system integrity.
</Intro>

## Philosophy

- **Collaboration over Gatekeeping**: Engineers, designers, and product managers share ownership of the system's health.
- **Flexibility with Accountability**: Teams may deviate from the system to meet deadlines, but all deviations ("snowflakes") [must be status tracked and reviewed](Introduction/Governance/Component Lifecycle) for potential integration. 
- **Iterative Improvement**: We embrace retrospection to refine components over time.

## How to use the Design System

1. **Check Storybook**:
    Teams should browse Storybook and default to using the design system by to help create new product work. The best case scenario is that a team comes to the library, finds the component they need and finds that it fulfills all their requirements. They plug in the component and carry on with more pressing matters. Hooray for best case scenarios!

    Questions? Don't see what you need, time to reach out to the design team!
2. **Talk**:
    If the team comes to the design system and doesn't find the component they need, if an existing component doesn't fulfill all the requirements, or if they're just not sure if the system has what they need, the first step is to reach out to Design System Lead (Carla Fabian). The design system team via Slack, issue trackers (Github, Jira, etc), or other channel (@TODO: the design system team should establish clear support protocol).
3. **Design & Build**:
    Product, Design, and Engineering will get to work, building the new component. For design, this may take the form of a wireframe, napkin sketch, comp, in-browser prototype, or any other artifact that quickly and clearly articulates the use case and defines the work to be done. For engineering, this may include proof-of-concepts, discovery spikes, or other vetting. Both Design and Engineering will deliver output for stakeholder approval.
4. **Review & Release**:
    Product, Design, and Engineering will regroup with stakeholders to review their work and determine whether that work meets all requirements. If things are missing, the teams will iterate over the concept and continue reviewing until the requirements are met and the new component is released to the design system. The new component is now ready to be integrated into the website itself.

---

## Phase 1: Talk & Ideation 

*Define the problem, scope requirements, and validate alignment with system goals.*  

The teams will have a conversation to better understand the issue, and then determine whether or not new work needs to happen. Often the design system team can help guide the product team to an existing solution that meets the requirements. Hooray for conversation!

If the teams determine the work is part of the design system, the work will be added to the design system backlog capturing the work to be done. The first thing that needs sorted is whether or not the the work is:

   1. **A "snowflake"**, which is a one-off component that only really pertains to one specific product or use case (such as a news design team project, a super intricate and specific data visualization, or any component that feels especially challenging to abstract into a general-use component)
   2. **Part of the design system**, which is a component or variation that is part of library that serves all products (such as adding a breadcrumbs component or perhaps adding an "x" button to a card component in order to make it dismissable)

If the teams decide the work is a snowflake, the work will be added to the specific product team's backlog in accordance with the design system's [snowflake guidelines](Introduction/Governance/Component Lifecycle).

We track planned work for components in the Design System Board on JIRA.

- If there's a ticket there you want to take on, send a Slack to #design-team or come to Design Team Office hours and lets talk about it!
- If the work you'd like to do isn't captured in a JIRA ticket, talk to us and we can work with you to create that ticket.
- If you would like to make a request for work to be done, please discuss with us on Slack or during Design Team Office Hours.
- If you'd like to pitch a change to the design system, please  come to Design Team Office Hours, or send a Slack message to #design-team.

### **Stakeholders**  

- **Product:** Drive initial requirements based on user/business needs.
- **Design:** Propose solutions aligned with the design system's principles.  
- **Engineering (Advisory Role):** Provide early feasibility feedback.  

### **Activities**  

- Define use cases, user stories, and edge cases.
- Conduct audits to avoid duplicating existing components.  
- Review system capabilities (e.g., existing tokens, Tailwind configurations).  

### **Outputs**  

- Component brief (problem statement, use cases, constraints).  

### **Key Considerations**  

- Product/Design must understand the system's exposed features (e.g., tokens, atomic design responsive patterns).
- Ideally, PMs/Designers are generally aware of the publishing workflow as a whole and the overall system's architecture **before** involving engineers.  
- Use system documentation to self-serve answers (e.g., "Can this be built with existing tokens?").  

---

## Phase 2: Design & Build

*Create Figma prototypes a using atomic design principles and design tokens. Cross-functional review to ensure alignment and readiness. Engineers develop the component in React, document in Storybook.*  

### **Stakeholders**  

- **Design:** Build in Figma, utilizing tokens adn adhering to established [Atomic Design Principles](Introduction/Governance/Atomic Design) and overall [design team practices](Introduction/Getting Started/For Designers).  
- **Product:** Validate final design against requirements and create ticket(s) capturing all requirements necessary for development.  
- **Engineers (Review):** Validate technical feasibility. Build with React, Tailwind, Storybook stories, Jest tests, and when necessasry possibly other tests such as Cypress E2E when appropriate.  

### **Activities**  

- Design component variants/states in Figma.  
- Apply existing design tokens (color, spacing, typography).  
- Document interaction states (hover, focus, loading).  
- Review designs and engineering plans for final stakeholder approval and sign-off.
- Engineers map Figma tokens to Tailwind classes (manually until style-dictionary is adopted).  
- Engineers build component with props for variants/states.  
- Engineers write unit tests (e.g., Jest).  
- Engineers write Storybook documentation, with contributions from design.

### **Outputs**  

- Figma file with component specs, tokens, and responsive breakpoints.  
- Signed-off Figma design.  
- Jira ticket for implementation.  
- React component code (along with appropriate test coverage).  
- Storybook documentation with usage examples, ideally in different states of stress.  

### **Key Considerations**  

- Designers must use **existing tokens** unless a net-new token is justified.  
- Engineers review for feasibility (e.g., "Can Tailwind implement this animation?").  
- All teams should reject designs that ignore system standards without justification.  
- Engineers and designers collaborate to resolve discrepancies (e.g., "Figma uses `spacing-4`, but Tailwind uses `p-4`").  

---

## Phase 3: Release & Review

*Finalize docs and validate quality. Release to production, gather feedback and iterate.*  

### **Stakeholders**  

- **Engineers:** Write technical docs with clarity for broad set of stakeholders.
- **QA:** Validate functionality and a11y.  
- **PMs/Designers:** Announce availability to product teams.  
- **All Teams:** Report issues or enhancement requests.  

### **Activities**  

- Merge changes and update design system version and changelog.
- Track adoption metrics.  
- Schedule retrospectives for complex components.

### **Activities**  

When the component is built, testing will ensue across the following areas:

- **Documentation** - do Storybook docs exist: props, examples, and "do's/don'ts".  
- **Content** – can this component or variation handle a variety of content situations (such as lengthy or internationalized text)?
- **Accessibility** – does this component meet or exceed accessibility requirements and follow accessibility guidelines?
- **Cross-browser/device** – test across supported browsers and devices
- **Responsive** – test across the entire resolution spectrum to ensure proper display on any screen size
- **Functionality** – unit testing for functionality
- **Create stress test examples** in the workshop to capture common, edge, and stress scenarios
- **Internal code review** – ensure component code meets atomic design principles, design system coding standards
- **Internal design review** – ensure work adheres to atomic design principles, the design language and meets all design requirements
- **Any other internal QA and testing**

### **Outputs**  

- Component available for reference in production Storybook.  
- Component available for adoption in production codebase.  
- Release notes communicated via Slack/email.
- Merged PR with tests passing.  

### **Key Considerations**  

- Treat documentation as a **living resource**—update as the component evolves.  
- Monitor usage and errors (e.g., via Datadog?, Vercel?).  

